Index: libs/canvas.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from PyQt5.QtGui import *\r\nfrom PyQt5.QtCore import *\r\nfrom PyQt5.QtWidgets import *\r\n\r\nfrom libs.shape import Shape\r\nfrom libs.utils import distance\r\n\r\nCURSOR_DEFAULT = Qt.ArrowCursor\r\nCURSOR_POINT = Qt.PointingHandCursor\r\nCURSOR_DRAW = Qt.CrossCursor\r\nCURSOR_MOVE = Qt.ClosedHandCursor\r\nCURSOR_GRAB = Qt.OpenHandCursor\r\n\r\n\r\nclass Canvas(QWidget):\r\n    zoomRequest = pyqtSignal(int)\r\n    scrollRequest = pyqtSignal(int, int)\r\n    newShape = pyqtSignal()\r\n    selectionChanged = pyqtSignal(bool)\r\n    shapeMoved = pyqtSignal()\r\n    drawingPolygon = pyqtSignal(bool)\r\n\r\n    CREATE, EDIT = list(range(2))\r\n\r\n    epsilon = 11.0\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super(Canvas, self).__init__(*args, **kwargs)\r\n        # Initialise local state.\r\n        self.mode = self.EDIT\r\n        self.shapes = []\r\n        self.current = None\r\n        self.selectedShape = None  # save the selected shape here\r\n        self.selectedShapeCopy = None\r\n        self.drawingLineColor = QColor(0, 0, 255)\r\n        self.drawingRectColor = QColor(0, 0, 255)\r\n        self.line = Shape(line_color=self.drawingLineColor)\r\n        self.prevPoint = QPointF()\r\n        self.offsets = QPointF(), QPointF()\r\n        self.scale = 1.0\r\n        self.labelFontSize = 8\r\n        self.pixmap = QPixmap()\r\n        self.visible = {}\r\n        self._hideBackround = False\r\n        self.hideBackround = False\r\n        self.hShape = None\r\n        self.hVertex = None\r\n        self._painter = QPainter()\r\n        self._cursor = CURSOR_DEFAULT\r\n        # Menus:\r\n        self.menus = (QMenu(), QMenu())\r\n        # Set widget options.\r\n        self.setMouseTracking(True)\r\n        self.setFocusPolicy(Qt.WheelFocus)\r\n        self.verified = False\r\n        self.drawSquare = False\r\n\r\n        # initialisation for panning\r\n        self.pan_initial_pos = QPoint()\r\n\r\n    def setDrawingColor(self, qColor):\r\n        self.drawingLineColor = qColor\r\n        self.drawingRectColor = qColor\r\n\r\n    def enterEvent(self, ev):\r\n        self.overrideCursor(self._cursor)\r\n\r\n    def leaveEvent(self, ev):\r\n        self.restoreCursor()\r\n\r\n    def focusOutEvent(self, ev):\r\n        self.restoreCursor()\r\n\r\n    def isVisible(self, shape):\r\n        return self.visible.get(shape, True)\r\n\r\n    def drawing(self):\r\n        return self.mode == self.CREATE\r\n\r\n    def editing(self):\r\n        return self.mode == self.EDIT\r\n\r\n    def setEditing(self, value=True):\r\n        self.mode = self.EDIT if value else self.CREATE\r\n        if not value:  # Create\r\n            self.unHighlight()\r\n            self.deSelectShape()\r\n        self.prevPoint = QPointF()\r\n        self.repaint()\r\n\r\n    def unHighlight(self):\r\n        if self.hShape:\r\n            self.hShape.highlightClear()\r\n        self.hVertex = self.hShape = None\r\n\r\n    def selectedVertex(self):\r\n        return self.hVertex is not None\r\n\r\n    def mouseMoveEvent(self, ev):\r\n        \"\"\"Update line with last point and current coordinates.\"\"\"\r\n        pos = self.transformPos(ev.pos())\r\n\r\n        # Polygon drawing.\r\n        if self.drawing():\r\n            self.overrideCursor(CURSOR_DRAW)\r\n            if self.current:\r\n                # Display annotation width and height while drawing\r\n                currentWidth = abs(self.current[0].x() - pos.x())\r\n                currentHeight = abs(self.current[0].y() - pos.y())\r\n                self.parent().window().labelCoordinates.setText(\r\n                        'Width: %d, Height: %d / X: %d; Y: %d' % (currentWidth, currentHeight, pos.x(), pos.y()))\r\n\r\n                color = self.drawingLineColor\r\n                if self.outOfPixmap(pos):\r\n                    # Don't allow the user to draw outside the pixmap.\r\n                    # Clip the coordinates to 0 or max,\r\n                    # if they are outside the range [0, max]\r\n                    size = self.pixmap.size()\r\n                    clipped_x = min(max(0, pos.x()), size.width())\r\n                    clipped_y = min(max(0, pos.y()), size.height())\r\n                    pos = QPointF(clipped_x, clipped_y)\r\n                elif len(self.current) > 1 and self.closeEnough(pos, self.current[0]):\r\n                    # Attract line to starting point and colorise to alert the\r\n                    # user:\r\n                    pos = self.current[0]\r\n                    color = self.current.line_color\r\n                    self.overrideCursor(CURSOR_POINT)\r\n                    self.current.highlightVertex(0, Shape.NEAR_VERTEX)\r\n\r\n                if self.drawSquare:\r\n                    initPos = self.current[0]\r\n                    minX = initPos.x()\r\n                    minY = initPos.y()\r\n                    min_size = min(abs(pos.x() - minX), abs(pos.y() - minY))\r\n                    directionX = -1 if pos.x() - minX < 0 else 1\r\n                    directionY = -1 if pos.y() - minY < 0 else 1\r\n                    self.line[1] = QPointF(minX + directionX * min_size, minY + directionY * min_size)\r\n                else:\r\n                    self.line[1] = pos\r\n\r\n                self.line.line_color = color\r\n                self.prevPoint = QPointF()\r\n                self.current.highlightClear()\r\n            else:\r\n                self.prevPoint = pos\r\n            self.repaint()\r\n            return\r\n\r\n        # Polygon copy moving.\r\n        if Qt.RightButton & ev.buttons():\r\n            if self.selectedShapeCopy and self.prevPoint:\r\n                self.overrideCursor(CURSOR_MOVE)\r\n                self.boundedMoveShape(self.selectedShapeCopy, pos)\r\n                self.repaint()\r\n            elif self.selectedShape:\r\n                self.selectedShapeCopy = self.selectedShape.copy()\r\n                self.repaint()\r\n            return\r\n\r\n        # Polygon/Vertex moving.\r\n        if Qt.LeftButton & ev.buttons():\r\n            if self.selectedVertex():\r\n                self.boundedMoveVertex(pos)\r\n                self.shapeMoved.emit()\r\n                self.repaint()\r\n            elif self.selectedShape and self.prevPoint:\r\n                self.overrideCursor(CURSOR_MOVE)\r\n                self.boundedMoveShape(self.selectedShape, pos)\r\n                self.shapeMoved.emit()\r\n                self.repaint()\r\n            else:\r\n                # pan\r\n                delta_x = pos.x() - self.pan_initial_pos.x()\r\n                delta_y = pos.y() - self.pan_initial_pos.y()\r\n                self.scrollRequest.emit(delta_x, Qt.Horizontal)\r\n                self.scrollRequest.emit(delta_y, Qt.Vertical)\r\n                self.update()\r\n            return\r\n\r\n        # Just hovering over the canvas, 2 posibilities:\r\n        # - Highlight shapes\r\n        # - Highlight vertex\r\n        # Update shape/vertex fill and tooltip value accordingly.\r\n        self.setToolTip(\"Image\")\r\n        for shape in reversed([s for s in self.shapes if self.isVisible(s)]):\r\n            # Look for a nearby vertex to highlight. If that fails,\r\n            # check if we happen to be inside a shape.\r\n            index = shape.nearestVertex(pos, self.epsilon)\r\n            if index is not None:\r\n                if self.selectedVertex():\r\n                    self.hShape.highlightClear()\r\n                self.hVertex, self.hShape = index, shape\r\n                shape.highlightVertex(index, shape.MOVE_VERTEX)\r\n                self.overrideCursor(CURSOR_POINT)\r\n                self.setToolTip(\"Click & drag to move point\")\r\n                self.setStatusTip(self.toolTip())\r\n                self.update()\r\n                break\r\n            elif shape.containsPoint(pos):\r\n                if self.selectedVertex():\r\n                    self.hShape.highlightClear()\r\n                self.hVertex, self.hShape = None, shape\r\n                self.setToolTip(\r\n                    \"Click & drag to move shape '%s'\" % shape.label)\r\n                self.setStatusTip(self.toolTip())\r\n                self.overrideCursor(CURSOR_GRAB)\r\n                self.update()\r\n                break\r\n        else:  # Nothing found, clear highlights, reset state.\r\n            if self.hShape:\r\n                self.hShape.highlightClear()\r\n                self.update()\r\n            self.hVertex, self.hShape = None, None\r\n            self.overrideCursor(CURSOR_DEFAULT)\r\n\r\n    def mousePressEvent(self, ev):\r\n        pos = self.transformPos(ev.pos())\r\n\r\n        if ev.button() == Qt.LeftButton:\r\n            if self.drawing():\r\n                self.handleDrawing(pos)\r\n            else:\r\n                selection = self.selectShapePoint(pos)\r\n                self.prevPoint = pos\r\n\r\n                if selection is None:\r\n                    # pan\r\n                    QApplication.setOverrideCursor(QCursor(Qt.OpenHandCursor))\r\n                    self.pan_initial_pos = pos\r\n\r\n        elif ev.button() == Qt.RightButton and self.editing():\r\n            self.selectShapePoint(pos)\r\n            self.prevPoint = pos\r\n        self.update()\r\n\r\n    def mouseReleaseEvent(self, ev):\r\n        if ev.button() == Qt.RightButton:\r\n            menu = self.menus[bool(self.selectedShapeCopy)]\r\n            self.restoreCursor()\r\n            if not menu.exec_(self.mapToGlobal(ev.pos()))\\\r\n               and self.selectedShapeCopy:\r\n                # Cancel the move by deleting the shadow copy.\r\n                self.selectedShapeCopy = None\r\n                self.repaint()\r\n        elif ev.button() == Qt.LeftButton and self.selectedShape:\r\n            if self.selectedVertex():\r\n                self.overrideCursor(CURSOR_POINT)\r\n            else:\r\n                self.overrideCursor(CURSOR_GRAB)\r\n        elif ev.button() == Qt.LeftButton:\r\n            pos = self.transformPos(ev.pos())\r\n            if self.drawing():\r\n                self.handleDrawing(pos)\r\n            else:\r\n                # pan\r\n                QApplication.restoreOverrideCursor()\r\n\r\n    def endMove(self, copy=False):\r\n        assert self.selectedShape and self.selectedShapeCopy\r\n        shape = self.selectedShapeCopy\r\n        # del shape.fill_color\r\n        # del shape.line_color\r\n        if copy:\r\n            self.shapes.append(shape)\r\n            self.selectedShape.selected = False\r\n            self.selectedShape = shape\r\n            self.repaint()\r\n        else:\r\n            self.selectedShape.points = [p for p in shape.points]\r\n        self.selectedShapeCopy = None\r\n\r\n    def hideBackroundShapes(self, value):\r\n        self.hideBackround = value\r\n        if self.selectedShape:\r\n            # Only hide other shapes if there is a current selection.\r\n            # Otherwise the user will not be able to select a shape.\r\n            self.setHiding(True)\r\n            self.repaint()\r\n\r\n    def handleDrawing(self, pos):\r\n        if self.current and self.current.reachMaxPoints() is False:\r\n            initPos = self.current[0]\r\n            minX = initPos.x()\r\n            minY = initPos.y()\r\n            targetPos = self.line[1]\r\n            maxX = targetPos.x()\r\n            maxY = targetPos.y()\r\n            self.current.addPoint(QPointF(maxX, minY))\r\n            self.current.addPoint(targetPos)\r\n            self.current.addPoint(QPointF(minX, maxY))\r\n            self.finalise()\r\n        elif not self.outOfPixmap(pos):\r\n            self.current = Shape()\r\n            self.current.addPoint(pos)\r\n            self.line.points = [pos, pos]\r\n            self.setHiding()\r\n            self.drawingPolygon.emit(True)\r\n            self.update()\r\n\r\n    def setHiding(self, enable=True):\r\n        self._hideBackround = self.hideBackround if enable else False\r\n\r\n    def canCloseShape(self):\r\n        return self.drawing() and self.current and len(self.current) > 2\r\n\r\n    def mouseDoubleClickEvent(self, ev):\r\n        # We need at least 4 points here, since the mousePress handler\r\n        # adds an extra one before this handler is called.\r\n        if self.canCloseShape() and len(self.current) > 3:\r\n            self.current.popPoint()\r\n            self.finalise()\r\n\r\n    def selectShape(self, shape):\r\n        self.deSelectShape()\r\n        shape.selected = True\r\n        self.selectedShape = shape\r\n        self.setHiding()\r\n        self.selectionChanged.emit(True)\r\n        self.update()\r\n\r\n    def selectShapePoint(self, point):\r\n        \"\"\"Select the first shape created which contains this point.\"\"\"\r\n        self.deSelectShape()\r\n        if self.selectedVertex():  # A vertex is marked for selection.\r\n            index, shape = self.hVertex, self.hShape\r\n            shape.highlightVertex(index, shape.MOVE_VERTEX)\r\n            self.selectShape(shape)\r\n            return self.hVertex\r\n        for shape in reversed(self.shapes):\r\n            if self.isVisible(shape) and shape.containsPoint(point):\r\n                self.selectShape(shape)\r\n                self.calculateOffsets(shape, point)\r\n                return self.selectedShape\r\n        return None\r\n\r\n    def calculateOffsets(self, shape, point):\r\n        rect = shape.boundingRect()\r\n        x1 = rect.x() - point.x()\r\n        y1 = rect.y() - point.y()\r\n        x2 = (rect.x() + rect.width()) - point.x()\r\n        y2 = (rect.y() + rect.height()) - point.y()\r\n        self.offsets = QPointF(x1, y1), QPointF(x2, y2)\r\n\r\n    def snapPointToCanvas(self, x, y):\r\n        \"\"\"\r\n        Moves a point x,y to within the boundaries of the canvas.\r\n        :return: (x,y,snapped) where snapped is True if x or y were changed, False if not.\r\n        \"\"\"\r\n        if x < 0 or x > self.pixmap.width() or y < 0 or y > self.pixmap.height():\r\n            x = max(x, 0)\r\n            y = max(y, 0)\r\n            x = min(x, self.pixmap.width())\r\n            y = min(y, self.pixmap.height())\r\n            return x, y, True\r\n\r\n        return x, y, False\r\n\r\n    def boundedMoveVertex(self, pos):\r\n        index, shape = self.hVertex, self.hShape\r\n        point = shape[index]\r\n        if self.outOfPixmap(pos):\r\n            size = self.pixmap.size()\r\n            clipped_x = min(max(0, pos.x()), size.width())\r\n            clipped_y = min(max(0, pos.y()), size.height())\r\n            pos = QPointF(clipped_x, clipped_y)\r\n\r\n        if self.drawSquare:\r\n            opposite_point_index = (index + 2) % 4\r\n            opposite_point = shape[opposite_point_index]\r\n\r\n            min_size = min(abs(pos.x() - opposite_point.x()), abs(pos.y() - opposite_point.y()))\r\n            directionX = -1 if pos.x() - opposite_point.x() < 0 else 1\r\n            directionY = -1 if pos.y() - opposite_point.y() < 0 else 1\r\n            shiftPos = QPointF(opposite_point.x() + directionX * min_size - point.x(),\r\n                               opposite_point.y() + directionY * min_size - point.y())\r\n        else:\r\n            shiftPos = pos - point\r\n\r\n        shape.moveVertexBy(index, shiftPos)\r\n\r\n        lindex = (index + 1) % 4\r\n        rindex = (index + 3) % 4\r\n        lshift = None\r\n        rshift = None\r\n        if index % 2 == 0:\r\n            rshift = QPointF(shiftPos.x(), 0)\r\n            lshift = QPointF(0, shiftPos.y())\r\n        else:\r\n            lshift = QPointF(shiftPos.x(), 0)\r\n            rshift = QPointF(0, shiftPos.y())\r\n        shape.moveVertexBy(rindex, rshift)\r\n        shape.moveVertexBy(lindex, lshift)\r\n\r\n    def boundedMoveShape(self, shape, pos):\r\n        if self.outOfPixmap(pos):\r\n            return False  # No need to move\r\n        o1 = pos + self.offsets[0]\r\n        if self.outOfPixmap(o1):\r\n            pos -= QPointF(min(0, o1.x()), min(0, o1.y()))\r\n        o2 = pos + self.offsets[1]\r\n        if self.outOfPixmap(o2):\r\n            pos += QPointF(min(0, self.pixmap.width() - o2.x()),\r\n                           min(0, self.pixmap.height() - o2.y()))\r\n        # The next line tracks the new position of the cursor\r\n        # relative to the shape, but also results in making it\r\n        # a bit \"shaky\" when nearing the border and allows it to\r\n        # go outside of the shape's area for some reason. XXX\r\n        # self.calculateOffsets(self.selectedShape, pos)\r\n        dp = pos - self.prevPoint\r\n        if dp:\r\n            shape.moveBy(dp)\r\n            self.prevPoint = pos\r\n            return True\r\n        return False\r\n\r\n    def deSelectShape(self):\r\n        if self.selectedShape:\r\n            self.selectedShape.selected = False\r\n            self.selectedShape = None\r\n            self.setHiding(False)\r\n            self.selectionChanged.emit(False)\r\n            self.update()\r\n\r\n    def deleteSelected(self):\r\n        if self.selectedShape:\r\n            shape = self.selectedShape\r\n            self.shapes.remove(self.selectedShape)\r\n            self.selectedShape = None\r\n            self.update()\r\n            return shape\r\n\r\n    def copySelectedShape(self):\r\n        if self.selectedShape:\r\n            shape = self.selectedShape.copy()\r\n            self.deSelectShape()\r\n            self.shapes.append(shape)\r\n            shape.selected = True\r\n            self.selectedShape = shape\r\n            self.boundedShiftShape(shape)\r\n            return shape\r\n\r\n    def boundedShiftShape(self, shape):\r\n        # Try to move in one direction, and if it fails in another.\r\n        # Give up if both fail.\r\n        point = shape[0]\r\n        offset = QPointF(2.0, 2.0)\r\n        self.calculateOffsets(shape, point)\r\n        self.prevPoint = point\r\n        if not self.boundedMoveShape(shape, point - offset):\r\n            self.boundedMoveShape(shape, point + offset)\r\n\r\n    def paintEvent(self, event):\r\n        if not self.pixmap:\r\n            return super(Canvas, self).paintEvent(event)\r\n\r\n        p = self._painter\r\n        p.begin(self)\r\n        p.setRenderHint(QPainter.Antialiasing)\r\n        p.setRenderHint(QPainter.HighQualityAntialiasing)\r\n        p.setRenderHint(QPainter.SmoothPixmapTransform)\r\n\r\n        p.scale(self.scale, self.scale)\r\n        p.translate(self.offsetToCenter())\r\n\r\n        p.drawPixmap(0, 0, self.pixmap)\r\n        Shape.scale = self.scale\r\n        Shape.labelFontSize = self.labelFontSize\r\n        for shape in self.shapes:\r\n            if (shape.selected or not self._hideBackround) and self.isVisible(shape):\r\n                shape.fill = shape.selected or shape == self.hShape\r\n                shape.paint(p)\r\n        if self.current:\r\n            self.current.paint(p)\r\n            self.line.paint(p)\r\n        if self.selectedShapeCopy:\r\n            self.selectedShapeCopy.paint(p)\r\n\r\n        # Paint rect\r\n        if self.current is not None and len(self.line) == 2:\r\n            leftTop = self.line[0]\r\n            rightBottom = self.line[1]\r\n            rectWidth = rightBottom.x() - leftTop.x()\r\n            rectHeight = rightBottom.y() - leftTop.y()\r\n            p.setPen(self.drawingRectColor)\r\n            brush = QBrush(Qt.BDiagPattern)\r\n            p.setBrush(brush)\r\n            p.drawRect(leftTop.x(), leftTop.y(), rectWidth, rectHeight)\r\n\r\n        if self.drawing() and not self.prevPoint.isNull() and not self.outOfPixmap(self.prevPoint):\r\n            p.setPen(QColor(0, 0, 0))\r\n            p.drawLine(self.prevPoint.x(), 0, self.prevPoint.x(), self.pixmap.height())\r\n            p.drawLine(0, self.prevPoint.y(), self.pixmap.width(), self.prevPoint.y())\r\n\r\n        self.setAutoFillBackground(True)\r\n        if self.verified:\r\n            pal = self.palette()\r\n            pal.setColor(self.backgroundRole(), QColor(184, 239, 38, 128))\r\n            self.setPalette(pal)\r\n        else:\r\n            pal = self.palette()\r\n            pal.setColor(self.backgroundRole(), QColor(232, 232, 232, 255))\r\n            self.setPalette(pal)\r\n\r\n        p.end()\r\n\r\n    def transformPos(self, point):\r\n        \"\"\"Convert from widget-logical coordinates to painter-logical coordinates.\"\"\"\r\n        return point / self.scale - self.offsetToCenter()\r\n\r\n    def offsetToCenter(self):\r\n        s = self.scale\r\n        area = super(Canvas, self).size()\r\n        w, h = self.pixmap.width() * s, self.pixmap.height() * s\r\n        aw, ah = area.width(), area.height()\r\n        x = (aw - w) / (2 * s) if aw > w else 0\r\n        y = (ah - h) / (2 * s) if ah > h else 0\r\n        return QPointF(x, y)\r\n\r\n    def outOfPixmap(self, p):\r\n        w, h = self.pixmap.width(), self.pixmap.height()\r\n        return not (0 <= p.x() <= w and 0 <= p.y() <= h)\r\n\r\n    def finalise(self):\r\n        assert self.current\r\n        if self.current.points[0] == self.current.points[-1]:\r\n            self.current = None\r\n            self.drawingPolygon.emit(False)\r\n            self.update()\r\n            return\r\n\r\n        self.current.close()\r\n        self.shapes.append(self.current)\r\n        self.current = None\r\n        self.setHiding(False)\r\n        self.newShape.emit()\r\n        self.update()\r\n\r\n    def closeEnough(self, p1, p2):\r\n        # d = distance(p1 - p2)\r\n        # m = (p1-p2).manhattanLength()\r\n        # print \"d %.2f, m %d, %.2f\" % (d, m, d - m)\r\n        return distance(p1 - p2) < self.epsilon\r\n\r\n    # These two, along with a call to adjustSize are required for the\r\n    # scroll area.\r\n    def sizeHint(self):\r\n        return self.minimumSizeHint()\r\n\r\n    def minimumSizeHint(self):\r\n        if self.pixmap:\r\n            return self.scale * self.pixmap.size()\r\n        return super(Canvas, self).minimumSizeHint()\r\n\r\n    def wheelEvent(self, ev):\r\n        qt_version = 4 if hasattr(ev, \"delta\") else 5\r\n        if qt_version == 4:\r\n            if ev.orientation() == Qt.Vertical:\r\n                v_delta = ev.delta()\r\n                h_delta = 0\r\n            else:\r\n                h_delta = ev.delta()\r\n                v_delta = 0\r\n        else:\r\n            delta = ev.angleDelta()\r\n            h_delta = delta.x()\r\n            v_delta = delta.y()\r\n\r\n        mods = ev.modifiers()\r\n        if Qt.ControlModifier == int(mods) and v_delta:\r\n            self.zoomRequest.emit(v_delta)\r\n        else:\r\n            v_delta and self.scrollRequest.emit(v_delta, Qt.Vertical)\r\n            h_delta and self.scrollRequest.emit(h_delta, Qt.Horizontal)\r\n        ev.accept()\r\n\r\n    def keyPressEvent(self, ev):\r\n        key = ev.key()\r\n        if key == Qt.Key_Escape and self.current:\r\n            print('ESC press')\r\n            self.current = None\r\n            self.drawingPolygon.emit(False)\r\n            self.update()\r\n        elif key == Qt.Key_Return and self.canCloseShape():\r\n            self.finalise()\r\n        elif key == Qt.Key_Left and self.selectedShape:\r\n            self.moveOnePixel('Left')\r\n        elif key == Qt.Key_Right and self.selectedShape:\r\n            self.moveOnePixel('Right')\r\n        elif key == Qt.Key_Up and self.selectedShape:\r\n            self.moveOnePixel('Up')\r\n        elif key == Qt.Key_Down and self.selectedShape:\r\n            self.moveOnePixel('Down')\r\n\r\n    def moveOnePixel(self, direction):\r\n        # print(self.selectedShape.points)\r\n        if direction == 'Left' and not self.moveOutOfBound(QPointF(-1.0, 0)):\r\n            # print(\"move Left one pixel\")\r\n            self.selectedShape.points[0] += QPointF(-1.0, 0)\r\n            self.selectedShape.points[1] += QPointF(-1.0, 0)\r\n            self.selectedShape.points[2] += QPointF(-1.0, 0)\r\n            self.selectedShape.points[3] += QPointF(-1.0, 0)\r\n        elif direction == 'Right' and not self.moveOutOfBound(QPointF(1.0, 0)):\r\n            # print(\"move Right one pixel\")\r\n            self.selectedShape.points[0] += QPointF(1.0, 0)\r\n            self.selectedShape.points[1] += QPointF(1.0, 0)\r\n            self.selectedShape.points[2] += QPointF(1.0, 0)\r\n            self.selectedShape.points[3] += QPointF(1.0, 0)\r\n        elif direction == 'Up' and not self.moveOutOfBound(QPointF(0, -1.0)):\r\n            # print(\"move Up one pixel\")\r\n            self.selectedShape.points[0] += QPointF(0, -1.0)\r\n            self.selectedShape.points[1] += QPointF(0, -1.0)\r\n            self.selectedShape.points[2] += QPointF(0, -1.0)\r\n            self.selectedShape.points[3] += QPointF(0, -1.0)\r\n        elif direction == 'Down' and not self.moveOutOfBound(QPointF(0, 1.0)):\r\n            # print(\"move Down one pixel\")\r\n            self.selectedShape.points[0] += QPointF(0, 1.0)\r\n            self.selectedShape.points[1] += QPointF(0, 1.0)\r\n            self.selectedShape.points[2] += QPointF(0, 1.0)\r\n            self.selectedShape.points[3] += QPointF(0, 1.0)\r\n        self.shapeMoved.emit()\r\n        self.repaint()\r\n\r\n    def moveOutOfBound(self, step):\r\n        points = [p1+p2 for p1, p2 in zip(self.selectedShape.points, [step]*4)]\r\n        return True in map(self.outOfPixmap, points)\r\n\r\n    def setLastLabel(self, text, line_color  = None, fill_color = None):\r\n        assert text\r\n        self.shapes[-1].label = text\r\n        if line_color:\r\n            self.shapes[-1].line_color = line_color\r\n\r\n        if fill_color:\r\n            self.shapes[-1].fill_color = fill_color\r\n\r\n        return self.shapes[-1]\r\n\r\n    def undoLastLine(self):\r\n        assert self.shapes\r\n        self.current = self.shapes.pop()\r\n        self.current.setOpen()\r\n        self.line.points = [self.current[-1], self.current[0]]\r\n        self.drawingPolygon.emit(True)\r\n\r\n    def resetAllLines(self):\r\n        assert self.shapes\r\n        self.current = self.shapes.pop()\r\n        self.current.setOpen()\r\n        self.line.points = [self.current[-1], self.current[0]]\r\n        self.drawingPolygon.emit(True)\r\n        self.current = None\r\n        self.drawingPolygon.emit(False)\r\n        self.update()\r\n\r\n    def loadPixmap(self, pixmap):\r\n        self.pixmap = pixmap\r\n        self.shapes = []\r\n        self.repaint()\r\n\r\n    def loadShapes(self, shapes):\r\n        self.shapes = list(shapes)\r\n        self.current = None\r\n        self.repaint()\r\n\r\n    def setShapeVisible(self, shape, value):\r\n        self.visible[shape] = value\r\n        self.repaint()\r\n\r\n    def currentCursor(self):\r\n        cursor = QApplication.overrideCursor()\r\n        if cursor is not None:\r\n            cursor = cursor.shape()\r\n        return cursor\r\n\r\n    def overrideCursor(self, cursor):\r\n        self._cursor = cursor\r\n        if self.currentCursor() is None:\r\n            QApplication.setOverrideCursor(cursor)\r\n        else:\r\n            QApplication.changeOverrideCursor(cursor)\r\n\r\n    def restoreCursor(self):\r\n        QApplication.restoreOverrideCursor()\r\n\r\n    def resetState(self):\r\n        self.restoreCursor()\r\n        self.pixmap = None\r\n        self.update()\r\n\r\n    def setDrawingShapeToSquare(self, status):\r\n        self.drawSquare = status\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- libs/canvas.py	(revision 16d8c53a8d193c1867f760068ed0bf0b4878b8bd)
+++ libs/canvas.py	(date 1611325279130)
@@ -107,8 +107,8 @@
                 # Display annotation width and height while drawing
                 currentWidth = abs(self.current[0].x() - pos.x())
                 currentHeight = abs(self.current[0].y() - pos.y())
-                self.parent().window().labelCoordinates.setText(
-                        'Width: %d, Height: %d / X: %d; Y: %d' % (currentWidth, currentHeight, pos.x(), pos.y()))
+                # self.parent().window().labelCoordinates.setText(
+                #         'Width: %d, Height: %d / X: %d; Y: %d' % (currentWidth, currentHeight, pos.x(), pos.y()))
 
                 color = self.drawingLineColor
                 if self.outOfPixmap(pos):
@@ -462,6 +462,7 @@
         p.scale(self.scale, self.scale)
         p.translate(self.offsetToCenter())
 
+        x, y = (self.pixmap.width() - self.size().width()) // 2, (self.pixmap.height() - self.size().height()) // 2
         p.drawPixmap(0, 0, self.pixmap)
         Shape.scale = self.scale
         Shape.labelFontSize = self.labelFontSize
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from PyQt5.QtWidgets import *\r\nfrom PyQt5.QtGui import *\r\nfrom PyQt5.QtCore import *\r\n\r\nfrom libs.image_editor import ImageEditor\r\n# from libs.user_editor import UserEditor\r\nfrom libs.camera import Camera\r\nfrom libs.user_interfaces import main\r\n\r\nimport cv2\r\nimport sys\r\nimport os\r\nimport qimage2ndarray\r\n\r\nIMG_EXTENSIONS = ('.BMP', '.GIF', '.JPG', '.JPEG', '.PNG', '.PBM', '.PGM', '.PPM', '.TIFF', '.XBM')\r\n\r\n\r\nclass MainWindow(QMainWindow, main.Ui_MainWindow):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.setupUi(self)\r\n        self.show()\r\n\r\n        # camera view\r\n        self.camera = Camera(0)\r\n        self.microscopeView.initialize(camera=self.camera)\r\n        self.microscopeView.setEnabled(True)\r\n\r\n        # database\r\n        self.logs = []\r\n        self.component_counter = 0\r\n        self.item_dict = {}\r\n        self.image_editor = ImageEditor(self.camera)\r\n        # self.user_editor = UserEditor()\r\n        self.load_database()\r\n\r\n        self.connect()\r\n\r\n    def connect(self):\r\n        self.databaseEditButton.clicked.connect(self._show_database_editor)\r\n        self.image_editor.close_event.connect(self._enable_videostream)\r\n        # self.operatorDataEditButton.clicked.connect(self._show_user_editor)\r\n\r\n    def _show_database_editor(self):\r\n        self.microscopeView.setEnabled(False)\r\n        self.image_editor.stream_enabled = True\r\n        self.image_editor.show()\r\n\r\n    @pyqtSlot()\r\n    def _enable_videostream(self):\r\n        self.image_editor.stream_enabled = False\r\n        self.microscopeView.setEnabled(True)\r\n\r\n    # def _show_user_editor(self):\r\n    #    self.user_editor.show()\r\n\r\n    def _clicked_on_item(self, item):\r\n        self.component_counter = self.item_dict[item.text()]\r\n\r\n    def display_item(self):\r\n        path = self.logs[self.component_counter]['path']\r\n        image = cv2.imread(path)\r\n        scale = (self.databaseComponentView.width() - 2) / image.shape[1]\r\n        image = cv2.resize(image, None, fx=scale, fy=scale)\r\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\r\n        image = qimage2ndarray.array2qimage(image)\r\n        self.databaseComponentView.setPixmap(QPixmap.fromImage(image))\r\n\r\n    def load_database(self):\r\n        directory = os.path.join(os.getcwd(), 'data')\r\n        self.logs = get_images(directory)\r\n        i = 0\r\n        for log in self.logs:\r\n            self.listView.addItem(QListWidgetItem(log['name']))\r\n            self.item_dict[log['name']] = i\r\n            i += 1\r\n        self.display_item()\r\n        self.listView.itemClicked.connect(self._clicked_on_item)\r\n\r\n\r\ndef get_images(directory):\r\n    res = []\r\n    for dir in os.listdir(directory):\r\n        path = os.path.join(directory, dir)\r\n        if os.path.isdir(path):\r\n            for file in os.listdir(os.path.join(directory, dir)):\r\n                if file.upper().endswith(IMG_EXTENSIONS):\r\n                    img_obj = {'name': dir, 'path': os.path.join(path, file)}\r\n                    res.append(img_obj)\r\n    return res\r\n\r\n\r\ndef terminate_app():\r\n    sys.exit()\r\n\r\n\r\ndef main():\r\n    app = QApplication(sys.argv)\r\n    window = MainWindow()\r\n    window.show()\r\n    app.exec_()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.py	(revision 16d8c53a8d193c1867f760068ed0bf0b4878b8bd)
+++ main.py	(date 1611254898219)
@@ -56,6 +56,7 @@
 
     def _clicked_on_item(self, item):
         self.component_counter = self.item_dict[item.text()]
+        self.display_item()
 
     def display_item(self):
         path = self.logs[self.component_counter]['path']
